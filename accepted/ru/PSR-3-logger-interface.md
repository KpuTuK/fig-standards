Logger Interface
================

В этом документе описывается общий интерфейс для библиотеки протоколирования.

Главная цель позволить библиотекам получать обьект `Psr\Log\LoggerInterface`
и запись журналов через него простым и универсальным способом. Фреймворки и CMS,
могут расширить интерфейс для своих собственных целей, но он должен оставаться 
совместимым с этим документом. Это гарантирует, что сторонние библиотеки, 
которые использует приложение, могут записывать в централизованных журналах приложения. 

Ключевые слова «НЕОБХОДИМО»/«ДОЛЖНО» («MUST»), «НЕДОПУСТИМО»/«НЕ ДОЛЖНО» («MUST NOT»), «ТРЕБУЕТСЯ»
(«REQUIRED»), «НУЖНО» («SHALL»), «НЕ ПОЗВОЛЯЕТСЯ» («SHALL NOT»), «СЛЕДУЕТ»
(«SHOULD»), «НЕ СЛЕДУЕТ» («SHOULD NOT»), «РЕКОМЕНДУЕТСЯ» («RECOMMENDED»),
«ВОЗМОЖНО» («MAY») и «НЕОБЯЗАТЕЛЬНО» («OPTIONAL»)
в этом документе должны расцениваться так, как описано в [RFC 2119].

Слово «исполнитель» в настоящем документе должно толковаться как реализация «LoggerInterface»
в связанных с журналом библиотеке или платформе.
Пользователи loggers, называются «пользователь».

[RFC 2119]: http://www.ietf.org/rfc/rfc2119.txt

1. Спецификации
-----------------

### 1.1 Базовая

- `LoggerInterface` предоставляет восемь методов для записи журналов восьми уровней  
[RFC 5424][] (Отладка, информация, уведомление, предупреждение, ошибка, критическое,
тревога, чрезвычайное).

[RFC 5424]: http://tools.ietf.org/html/rfc5424

- Девятый метод, `log»`, принимает уровень журнала в качестве первого аргумента.
Вызов этого метода с одной из констант уровня журнала должен иметь
тот же результат вызова как и метода конкретного уровня. Вызов этого метода с уровнем,
не определенным в спецификации должен выбрасывать исключение `Psr\Log\InvalidArgumentException`, 
если уровень не осуществлен. Пользователи не должны использовать свой уровень не зная наверняка
что данная реализация поддерживает его.

### 1.2 Сообщения

- Каждый метод принимает строку как сообщение, или объект с помощью метода `__toString()`.
Разработчики могут специально обрабатывать переданные обьекты. Если это не так, 
разработчики должны привести его в строку.

- Сообщение может содержать значения, которыми разработчики могут заменить
значения из массива контекста.

Вводимые имена должны соответствовать ключам в массиве контекста.

Имена значений, должны быть с одной открывающей фигурной скобкой ' {' и
друной закрывающей фигурной скобкой '}'. Между разделителями и именами значений не должно быть пробелов.

Имена значений должны состоять только из знаков `A-Z, a-z, 0-9`, подчеркивания `_` и точки `.`.

Использование других символов зарезервировано для будущих модификаций спецификации значений.

Разработчики могут использовать значения для реализации различных экраннирований и переводов журналов для отображения.

Пользователи не должны предварительно экраннировать значения заполнителей, так как они не могут знать,
где будет отображаться контекст данных.

Ниже приведен пример реализации экранирования значений, предусмотренный только для справочных целей:

 ```php
  /**
   * Экранирует значения в контексте сообщения.
   */
  function interpolate($message, array $context = array())
  {
      // Создание и замена массива с фигурными скобками вокруг ключей контекста
      $replace = array();
      foreach ($context as $key => $val) {
          $replace['{' . $key . '}'] = $val;
      }

      //Заменить значения в сообщении и вернуть их
      return strtr($message, $replace);
  }

  // Сообщение с заменяемыми именами значений
  $message = "User {username} created";

  // Массив контекста с именами и значениями
  $context = array('username' => 'bolivar');

  // Выводит "User bolivar created"
  echo interpolate($message, $context);
  ```
